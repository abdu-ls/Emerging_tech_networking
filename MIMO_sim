import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

#   function for square MIMO 
def CapacitySquare(M, snr_db_list, n_realizations=1000):
    Nt = Nr = M
    capacities = np.zeros((len(snr_db_list), n_realizations))
    for i, snr_db in enumerate(snr_db_list):
        snr_lin = 10**(snr_db/10.0)
        per_ant_power = snr_lin / Nt
        for r in range(n_realizations):
            # i.i.d. Rayleigh channel
            H = (np.random.normal(size=(Nr, Nt)) + 1j*np.random.normal(size=(Nr, Nt))) / np.sqrt(2.0)
            HH = H @ H.conj().T
            sign, logdet = np.linalg.slogdet(np.eye(Nr) + per_ant_power * HH)
            capacities[i, r] = logdet / np.log(2.0)  # log base 2
    return capacities.mean(axis=1), capacities.std(axis=1)

#   Parameters 
np.random.seed(42)
snr_db_list = np.linspace(-10, 30, 21)  # SNR range: -10 to 30 dB

#   4×4 Monte Carlo simulation 
avg_cap_4x4, std_4x4 = CapacitySquare(4, snr_db_list, n_realizations=1000)

#   64×64 Approximation using channel hardening 
snr_lin = 10**(snr_db_list/10.0)
approx_cap_64 = 64 * np.log2(1 + snr_lin)

#  Plot results
plt.figure(figsize=(9,6))
plt.plot(snr_db_list, avg_cap_4x4, label='4×4 (Monte Carlo)')
plt.plot(snr_db_list, approx_cap_64, label='64×64 (Approx: 64·log2(1+SNR))')
plt.fill_between(snr_db_list, avg_cap_4x4-std_4x4, avg_cap_4x4+std_4x4, alpha=0.15)
plt.xlabel('SNR (dB)')
plt.ylabel('Ergodic Capacity (bits/s/Hz)')
plt.title('MIMO Ergodic Capacity vs SNR (4×4 simulated, 64×64 approximated)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

#   Summary table for selected SNRs 
selected_idxs = [0, 5, 10, 15, 20]
summary = pd.DataFrame({
    'SNR (dB)': snr_db_list[selected_idxs],
    'Avg Cap 4×4 (bits/s/Hz)': np.round(avg_cap_4x4[selected_idxs], 3),
    'Std 4×4': np.round(std_4x4[selected_idxs], 3),
    'Approx Cap 64×64 (bits/s/Hz)': np.round(approx_cap_64[selected_idxs], 3)
})

print(summary)
