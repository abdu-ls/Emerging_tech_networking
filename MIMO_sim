import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Simulation function for square MIMO 
def simulate_capacity_square(M, snr_db_list, n_realizations=100):
    Nt = Nr = M
    capacities = np.zeros((len(snr_db_list), n_realizations))
    for i, snr_db in enumerate(snr_db_list):
        snr_lin = 10**(snr_db/10.0)
        per_ant_power = snr_lin / Nt
        for r in range(n_realizations):
            # i.i.d. Rayleigh channel
            H = (np.random.normal(size=(Nr, Nt)) + 1j*np.random.normal(size=(Nr, Nt))) / np.sqrt(2.0)
            HH = H @ H.conj().T
            sign, logdet = np.linalg.slogdet(np.eye(Nr) + per_ant_power * HH)
            capacities[i, r] = logdet / np.log(2.0)  # log base 2
    return capacities.mean(axis=1), capacities.std(axis=1)

#  Parameters 
np.random.seed(42)
snr_db_list = np.linspace(-5, 20, 6)   # smaller SNR range, fewer points
n_realizations_64 = 50                 # fewer runs for 64×64 (heavy computation)

#  4×4 Monte Carlo simulation (reference) 
avg_cap_4x4, std_4x4 = simulate_capacity_square(4, snr_db_list, n_realizations=500)

#  64×64 Monte Carlo simulation 
avg_cap_64, std_64 = simulate_capacity_square(64, snr_db_list, n_realizations=n_realizations_64)

#  64×64 Approximation using channel hardening 
snr_lin = 10**(snr_db_list/10.0)
approx_cap_64 = 64 * np.log2(1 + snr_lin)

#  Plot results 
plt.figure(figsize=(9,6))
plt.plot(snr_db_list, avg_cap_4x4, 'o-', label='4×4 (Monte Carlo)')
plt.plot(snr_db_list, avg_cap_64, 's-', label='64×64 (Monte Carlo)')
plt.plot(snr_db_list, approx_cap_64, 'd--', label='64×64 (Approx: 64·log2(1+SNR))')
plt.fill_between(snr_db_list, avg_cap_64-std_64, avg_cap_64+std_64, alpha=0.15, color='orange')
plt.xlabel('SNR (dB)')
plt.ylabel('Ergodic Capacity (bits/s/Hz)')
plt.title('MIMO Ergodic Capacity vs SNR\n(4×4 & 64×64 simulated; 64×64 also approximated)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

